\section{Preliminaries}

\subsection{A discrete grid of robots}

\fda{One ``git''-related suggestion: break often lines so that when comparing different commits there is less text to look at. 
A simple line break doesn't change the tex-output. 
I usually break the line after each period.}
% WORKSPACE 
Let our grid-based workspace be modeled as a graph \ilmath{ G \coloneqq (V, E)}. Let it be a rectangle \ilmath{n_1 \times n_2} where \ilmath{n_1, n_2 \geq 2 \text{ and } n_1, n_2 \in \mathbb{N}}. 
\fda{No need to say ``label'' here. 
It is directly the definition of \(V\).}
Label the vertices as \ilmath{V = \set{1, 2, \dots , n_1} \times \set{1, 2, \dots , n_2}}, and denote their \ilmath{x} and \ilmath{y} -coordinates by \ilmath{v_x} and \ilmath{v_y} respectively for any vertex \ilmath{v \in V}.
\fda{I would rephrase the latter sentence more formally: 
for any \(v \in V\), let \(v_x, v_y\) ne such that \(v = (v_x, v_y)\). 
We will call \(v_x\) the \(x\)-coordinate of \(v\), and \(v_y\) it \(y\)-coordinate.}
To measure distance, we use the \emph{Manhattan norm} \ilmath{L_1 = \manhattan{v - w} \coloneqq (\abs{v_x - w_x} + \abs{v_y - w_y})}. Using this, the edges can be defined as \ilmath{E = \set{(v, w) \mid \manhattan{v - w} = 1 \text{ for } v, w \in V}}. In other words, nodes are only connected to their up to four immediate neighbors in the plane \fda{grid?}.

% ROBOTS AND CONFIGURATIONS
Let there be \ilmath{N \leq (\nngrid)} \fda{why parantheses?} robots in our workspace. We can identify them by a number \ilmath{r \in R := \set{1, 2, \dots , N} \subset \mathbb{N}}. Let \ilmath{\bot} signify an empty vertex \fda{I would write ``let \(\bot\) be a symbol whose purpose is to identify empty vertices''}. A \emph{configuration} is then a mapping \ilmath{\conf{} : V \mapsto \set{1, 2, \dots, N, \bot}} injective upon the robots in \ilmath{R}. Injectivity implies no two vertices in \ilmath{V} can be occupied at once, so there will always be exactly \ilmath{(\nngrid - N)} empty squares in the grid.

% CONFIGURATION INVERSE
The \emph{inverse} of a configuration \ilmath{\iconf{}{r} = (x, y), \; r \in R} \fda{,} is the \emph{position} of a robot.
\fda{for the latter sentence, I would say that the inverse of a configuration is another function (or mapping) that maps robot labels into positions - it is not a position!}
The robots move synchronously and in parallel, up to a single edge at a time. A valid (no-collision) configuration \ilmath{\conf{1}} can thus be \emph{transformed} into another valid configuration \ilmath{\conf{2}} in a \emph{single step} if and only if:

% TRANSFORMATION REQUIREMENTS
\begin{align}
	& \parens{\iconf{1}{r} = \iconf{2}{r} \lor (\iconf{1}{r}, \iconf{2}{r}) \in E, \; \forall r \in R}\label{req:limited_movement}\\
	\land & \parens{\nconf{1}{v} = \nconf{2}{w} \Rightarrow \nconf{2}{v} \neq \nconf{1}{w}, \; \forall v, w \in V}\label{req:no_swaps}
\end{align}

In other words, \cref{req:limited_movement} implies \fda{means?} a robot can stay in place or move to a neighboring square at every step, while \cref{req:no_swaps} forbids two robots from swapping places in a single transformation step (and they can never occupy the same vertex), equivalent to a collision in the real world.

% SCHEDULE
Denote a single transformation step as \fda{denote goes with ``by'', not ``as''} \ilmath{\conf{i} \rightarrow \conf{i + 1}}. A \emph{schedule} is a sequence of transformation steps \ilmath{S \coloneqq \conf{1} \rightarrow \conf{2} \rightarrow \cdots \rightarrow \conf{k}}. A configuration \ilmath{\conf{s}} can be transformed into a configuration \ilmath{\conf{t}} if there exists a schedule \ilmath{\conf{s} \rightarrow \conf{s + 1} \rightarrow \cdots \rightarrow \conf{t - 1} \rightarrow \conf{t}}.

% PROBLEM DEFINITION
\begin{definition}\label{def:motion_planning_problem}
	Given a start configuration \ilmath{\conf{s}} and a target configuration \ilmath{\conf{t}} of a workspace, the \emph{motion planning problem} ask \fda{asks} to find a \emph{schedule} \fda{you already put ``schedule'' in emph before: no need to do it anymore} that transforms \ilmath{\conf{s}} into \ilmath{\conf{t}}.
\end{definition}

Denote the tuple of a workspace and two configurations \ilmath{I \coloneqq \parens{G,\ \conf{s},\ \conf{t}}} as a problem \emph{instance}. 

\begin{remark}\label{remark:reachability}
	For a \ilmath{2 \times 2} square and any \ilmath{1 \times n} rectangle, where \ilmath{n \geq 2}, there exist pairs of configurations that are not reachable from each other via any schedule. See \cref{fig:reachability} for an example. For any other rectangular workspace there always exists such a schedule. 
\end{remark}

% IMPOSSIBLE 2*2 SQUARE FIGURE
\begin{figure}[h]
	\centering
	\includegraphics[width=4cm]{include/impossible_2x2.eps}
	\caption{A minimal example of an unsolvable motion planning problem: there exists no valid schedule which swaps the green and blue robots.}\label{fig:reachability}
\end{figure}

% MAKESPAN
\begin{definition}\label{def:makespan}
	The number of single transformation steps in a schedule is called the \emph{makespan} of that schedule.
\end{definition}

\begin{definition}\label{def:optimality}
	Let \ilmath{\schedules} denote the set of all valid schedules for some problem instance \ilmath{I}. A schedule \ilmath{S_\text{opt}} is \emph{optimal} with respect to some cost function \ilmath{f : \schedules \mapsto \mathbb{N}} mapping all valid schedules to some integer value if and only if \ilmath{f(S) \geq f(\sopt)} for all such valid schedules \ilmath{S} \fda{\(\in \schedules\)}.
\end{definition}

% M3PP -- MINIMUM MAKESPAN MOTION PLANNING PROBLEM
\begin{definition}\label{def:m3pp}
	Let the makespan of a schedule be such a cost function: \ilmath{M : S \mapsto \parens{\text{number of steps in S}}}. The \emph{minimum makespan motion planning problem} asks to find an \emph{optimal} schedule with respect to the makespan \ilmath{M} for some input problem instance.
\end{definition}

\begin{remark}
	The \emph{minimum makespan} for any motion planning problem instance \ilmath{I \coloneqq \parens{G,\ \conf{s},\ \conf{t}}} is bounded below by \ilmath{\max(\set{\manhattan{\iconf{s}{r}, \; \iconf{t}{r}}, \; r \in R})}.
\end{remark}

\begin{definition}
	Let the aforementioned lower bound to a schedule with makespan \ilmath{M} be denoted by \ilmath{L}. The \ilmath{\emph{stretch factor}} for that schedule is then defined as \ilmath{\frac{M}{L} \geq 1} \fda{ the inequality should be described later: defined as \(\frac ML\), which is always at least 1}.
\end{definition}

\subsection{Some general notation}

\begin{definition}
	Let \ilmath{f(n)} be some function. \fda{don't start a sentence with a math formula} \ilmath{f(n)} has an asymptotic upper bound \ilmath{g(n)} if there are some constants \ilmath{c \text{ and } n_0} such that \ilmath{f(n) \leq c\cdot g(n),\ \forall n \geq n_0}. It is then denoted with slight abuse of notation \ilmath{f(n) = O(g(n))}. \fda{no need to say that it is an abuse of notation, this is pretty standard. 
	It is called Bachmannâ€“Landau notation} 
\end{definition}

Let \emph{A} be some algorithm. \fda{\(A\) is said to run in \emph{polynomial time} ... if the execution of \(A\) by a deterministic Turing machine is done in a polynomial number of steps w.r.t.\ the input bit length... (are yyou sure you want do define this? I think is better to assume it is known)}
It is \emph{polynomial time} and often said to be \emph{efficient} if the runtime of \emph{A} is bounded by some polynomial function \ilmath{T(A) = O(n^c)} for some constant \ilmath{c}.

Let OPT be the optimal (minimum) value of some function \ilmath{f}. If some algorithm \ilmath{A} can always find a solution that maps to within a \ilmath{\rho}-factor of the optimal value: \ilmath{OPT \leq f(x_A) \leq \rho \cdot OPT}, the algorithm is called a \ilmath{\rho}-approximation algorithm. 
